#+Title: Evaluating Navigational RDF Queries over Web
#+Author: Baier, Daroch, Reutter and Vrgoc
#+Email: {jabaier,jreutter,dvrgoc}@ing.puc.cl, ddaroch@uc.cl
#+Web: doge.ing.puc.cl/Dietrich/Slides/evaluating_nav_queries
#+Language: en
#+Date: 2017-07-04

* Tasks :noexport:
** TODO check if the RDF Subject can be a String of data
* Setup                                                            :noexport:
#+SEQ_TODO: TODO REVIEW | DONE
#+REVEAL_ROOT: http://localhost:8000
# #+REVEAL_ROOT: file:///home/dietr1ch/Public/Slides/evaluating_nav_queries/
# #+REVEAL_ROOT: https://doge.ing.puc.cl/Dietr1ch/Slides/evaluating_nav_queries/
#+REVEAL_HEAD_PREAMBLE: <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/d3/4.9.1/d3.min.js'></script>

# Local Variables:
# eval: (add-hook 'after-save-hook (org-reveal-export-to-html))
# eval: (add-hook 'after-save-hook (org-pandoc-export-to-beamer-pdf))
# End:


* Config                                                          :noexport:
#+STARTUP: overview

** Numbering
#+OPTIONS: toc:nil
# Remove numbering from sections and subsections
#+OPTIONS: num:nil

** Reveal
#+REVEAL_HLEVEL: 2
#+REVEAL_SPEED: 2
#+OPTIONS: reveal_slide_number:h.v

# Adding plugings without their dependencies might break your slides

#+REVEAL_EXTRA_JS: { src: 'plugin/math/math.js', async: true }, { src: 'plugin/zoom-js/zoom.js', async: true }
# #+REVEAL_PLUGINS: (highlight markdown notes reveal-progress)
#+REVEAL_PLUGINS: (highlight markdown notes)


*** Looks
 #+REVEAL_TRANS: slide
 # Theme (black moon night blood)
 #+REVEAL_THEME: black
 # Target 1366x768, 16:9 and not far from 1024x768 widely used on projectors
 #+OPTIONS: reveal_width:1366 reveal_height:768
 # #+REVEAL_EXTRA_CSS: custom.css
*** Reveal
 #+OPTIONS: reveal_center:t
 #+OPTIONS: reveal_progress:t
 #+OPTIONS: reveal_history:nil
 #+OPTIONS: reveal_control:t
 #+OPTIONS: reveal_rolling_links:t
 #+OPTIONS: reveal_keyboard:t
 #+OPTIONS: reveal_overview:nil

** Beamer
#+BEAMER_THEME: Rochester [height=20pt]
# #+LATEX_HEADER: \usepackage{verbatim}

# #+OPTIONS: H:2
# #+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t


* Introduction
  :PROPERTIES:
  :reveal_background: images/lod-1080-fade.png
  :reveal_background_trans: slide
  :END:

** Motivation
*** Sharing across databases
    #+ATTR_REVEAL: :frag (appear)
		- Information on relational databases is hard to share
      #+ATTR_REVEAL: :frag (appear)
			- Different format, schema and access policies
			- Sharing problems cause data to become outdated
		- A different approach is needed


#+LaTeX: \note{
#+BEGIN_NOTES
Relational databases are a closed source of information, which makes it hard to
share

Duplicating the shared data on all databases does not makes much sense
 and it can easily become stale as it won't be maintained by the real owner
#+END_NOTES
#+LaTeX: }

*** A Web-like approach
		The Web provides linked documents with human readable information

    #+ATTR_REVEAL: :frag (appear)
		- Documents are linked
			- Real owners can update the data
			- Documents can be navigated across different servers
		- It's distributed
			- Can scale-out

** Linked Data
*** One Database to rule them all
		LD movement proposes using a graph made of IRIs and strings

    #+ATTR_REVEAL: :frag (appear)
		- Uses links to data instead of copies
		- Uses IRIs as data identifiers
		- Uses IRIs as relation identifiers
      #+ATTR_REVEAL: :frag (appear)
			- And suggests collection of relations to use

#+LaTeX: \note{
#+BEGIN_NOTES
Following the web, LD proposes using a graph, but instead of documents and
links, it explicitly uses identifiers as things rather than only identifiers of
documents
#+END_NOTES
#+LaTeX: }

*** Resource Description Framework
		Defines the layout of the data

    #+ATTR_REVEAL: :frag (appear)
		- An RDF triple is a tuple $(S, P, O)$
			- $Subject$   is an IRI or a string
			- $Predicate$ is an IRI representing a relation
			- $Object$    is an IRI or a string
		  - It's essentially the unit of information
		- Data is meant to be retrieved from the internet
			- Open-world assumption must be used

#+LaTeX: \note{
#+BEGIN_NOTES
RDF is a specification on of the data layout
An RDF triple is the essential unit of information, it relates some objects
using a predicate.

What is really interesting about RDF, is that IRIs become identifiers for
the data, this enables identifiers to be shared across databases, and also to
have a common vocabulary on the relations.
This change allows different databases to be combined without the need for human
review of the schemas compatibility. No conversions are needed.
#+END_NOTES
#+LaTeX: }

*** An example
#+BEGIN_SRC txt
prefix ht: <https://ht.acm.org/rdf/>
prefix dc: <http://purl.org/dc/elements/1.1/>
prefix sw: <http://www.w3.org/2001/sw/>

sw:RDFCore/ntriples dc:creator   "Dave Beckett"       .
sw:RDFCore/ntriples dc:creator   "Art Barstow"        .
sw:RDFCore/ntriples dc:publisher <http://www.w3.org/> .
#+END_SRC

*** Why RDF?
    #+ATTR_REVEAL: :frag (appear)
		- Different databases can be trivially joined
			- No schema compatibility problems or conversions.
		- Database can be sharded

** Querying Linked Data
*** A data model is not enough
		Databases must be queried to be useful

#+LaTeX: \note{
#+BEGIN_NOTES
RDF is a data model for storing information, but having information is worthless
without a way to query it
So far LD proposes a model for storing information in a distributed fashion.
#+END_NOTES
#+LaTeX: }


*** SPARQL
		A SQL-like language for querying and modifying graph databases

    #+ATTR_REVEAL: :frag (appear)
		- A query language
			- Queries are RDF graphs with variables and restrictions
			- Answers are computed by pattern matching
		- SPARQL servers provide
			- An SPARQL endpoint to consume or update RDF data
			- A store for the data
#+LaTeX: \note{
#+BEGIN_NOTES
SPARQL is a language for querying graphs, it looks like SQL and relies on
subgraph matching specifying queries.

SPARQL servers provide endpoints (services) to interact
#+END_NOTES
#+LaTeX: }


*** REVIEW Problems with SPARQL

    #+ATTR_REVEAL: :frag (appear)
		- Querying multiple servers is hard
			- Query federation allows specifying multiple servers
				- Lacks discoverability
				- Queries are harder to write
		- Computation is done completely server-side
			- Exposing SPARQL endpoints is troublesome
			- Queries can be hard
				- Subgraph matching is NP-complete

#+LaTeX: \note{
#+BEGIN_NOTES
SPARQL has a few problems.

Servers must handle too much of the complexity as the only task for clients is
to send the query and receive the final answer.
#+END_NOTES
#+LaTeX: }

* Navigational Queries
** TODO Navigation
*** Searching data the way you browse for it
    #+ATTR_REVEAL: :frag (appear)
		- You don't know which server has the answer
			- From a starting point you follow links onto your answers
		- Servers just offer data
			- You do the computation and ask for data on the fly
		- You don't know whether you see all the data
			- Open-world semantics are intrinsic
			- You probably can't have all of it

*** REVIEW Property Paths
		Property paths allow expressing composed relations using regular expressions
    over IRIs and their inverses

    #+ATTR_REVEAL: :frag (appear)
		- Easier to compute than general patterns
		- SPARQL supports them too
			- But lacks the discoverability they could have
			- Patterns can prove the same relation in many ways
				- All proofs are usually too much

#+LaTeX: \note{
#+BEGIN_NOTES

Servers must handle too much of the complexity as the only task for clients is
to send the query and receive the final answer.
#+END_NOTES
#+LaTeX: }


*** TODO Property Path examples

#+BEGIN_LaTeX
\begin{align*}
(successor)^*&  \\
(directed \cdot directed^{-})^*& \cdot name  \\
(director^{-} \cdot director)^*& \cdot name
\end{align*}
#+END_LaTeX


** TODO Automata
*** TODO Definition
		Property Path Automata

#+reveal_html:	<img class="fragment figure" src="graphics/friend-star.png"/>
#+LaTeX: \center\includegraphics[width=0.5\textwidth]{graphics/friend-star.png}
    #+ATTR_REVEAL: :frag (appear)
		- It's a regular automaton over alphabet of IRIs and their inverses

*** TODO Definition
    #+ATTR_REVEAL: :frag (appear)
		- AOEU

*** TODO Heuristic
		Distances to accepting states are lower bounds for finding answers


** TODO Search
*** TODO Advantages
**** Shortest path proves relation
*** TODO A* speed up using query information
		- Answers are retrieved earlier
		- All answers still requires checking all possibilities
			- But earlier results improve queries with limits


** TODO Implementation details
*** TODO Heuristic
		- The heuristic can be precomputed
		- Early expansion reward shift
			- Add an example that shows the speedup

** TODO Evaluation
*** TODO Experiment setup
		- Details about doge
			- i5-4xxx @ 3GHz
			- 8 GiB RAM
			- Little CPU needed
			- Memory used is linear on the dereferenced data
			- Time dominated by dereference time
				- It's important to do good and parallel scheduling
		- Servers used

*** TODO Experiment discussion
		- Relative cost to CPU instruction table
			- CPU is free
			- Network is the active constraint
		- Time dominated by dereference time
			- Communication needs improvement
				- Parallel channels
				- Compression
				- Simple queries
					# - Linked Data Fragments offers this
				- Parallel Async IO is needed on clients

* Questions
* Extra
** TODO Informed search is superior
** TODO Heuristic optimization demo
** TODO Evaluation
*** TODO Experiments
Experiments are available on the [experiments.html][experiment slides]
* Thanks
* Old                                                             :noexport:

#+BEGIN_NOTES
Imagine you are given a flash drive with the contents of the internet, but at
the cost of not having internet anymore. Would that be useful?
Great part of the value of the internet is on being able to access living
information. Most of the information on that flash drive will become irrelevant
or stale
Databases face a similar problem, they don't usually have access to the outside
world. 
#+END_NOTES
