<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Evaluating Navigational RDF Queries over Web</title>
<meta name="author" content="(Baier, Daroch, Reutter and Vrgoc)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./css/reveal.css"/>

<link rel="stylesheet" href="./css/theme/black.css" id="theme"/>

<link rel="stylesheet" href="./lib/css/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><h1 class="title">Evaluating Navigational RDF Queries over Web</h1><h2 class="author">Baier, Daroch, Reutter and Vrgoc</h2><h2 class="date">CIWS &amp; PUC Chile</h2><p class="date">Created: 2017-07-05 Wed 23:23</p>
</section>

<section>
<section id="slide-org681afb4" data-background="images/lod-1080-fade.png" data-background-transition="slide">
<h2 id="org681afb4">Introduction</h2>
</section>
</section>
<section>
<section id="slide-orgf18fb22">
<h3 id="orgf18fb22">Motivation</h3>
<div class="outline-text-3" id="text-orgf18fb22">
</div></section>
<section id="slide-org521affa">
<h4 id="org521affa">Sharing across databases</h4>
<ul>
<li class="fragment appear">Information on relational databases is hard to share
<ul>
<li>Different format, schema and access policies</li>
<li>Sharing problems cause data to become outdated</li>

</ul></li>
<li class="fragment appear">A different approach is needed</li>

</ul>


<aside class="notes">
<p>
Relational databases are a closed source of information, which makes it hard to
share
</p>

<p>
Duplicating the shared data on all databases does not makes much sense
 and it can easily become stale as it won't be maintained by the real owner
</p>

</aside>

</section>
<section id="slide-orge96f794">
<h4 id="orge96f794">A Web-like approach</h4>
<p>
The Web provides linked documents with human readable information
</p>

<ul>
<li class="fragment appear">Documents are linked
<ul>
<li>Real owners can update the data</li>
<li>Documents can be navigated across different servers</li>

</ul></li>
<li class="fragment appear">It's distributed
<ul>
<li>Can scale-out</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org15e3ae6">
<h3 id="org15e3ae6">Linked Data</h3>
<div class="outline-text-3" id="text-org15e3ae6">
</div></section>
<section id="slide-org53635b7">
<h4 id="org53635b7">One Database to rule them all</h4>
<p>
LD movement proposes a way to model data that can be linked and distributed
</p>

<ul>
<li class="fragment appear">A Graph made of IRIs and strings
<ul>
<li>IRIs link data instead of copying it</li>
<li>Uses IRIs as data identifiers</li>
<li>Uses IRIs as relation identifiers
<ul>
<li>And suggests collection of relations to use</li>

</ul></li>

</ul></li>

</ul>


<aside class="notes">
<p>
Following the web, LD proposes using a graph, but instead of documents and
links, it explicitly uses identifiers as things rather than only identifiers of
documents
</p>

</aside>

</section>
<section id="slide-org628a166">
<h4 id="org628a166">Resource Description Framework</h4>
<p>
Defines the layout of the data
</p>

<ul>
<li class="fragment appear">An RDF triple is a tuple \((S, P, O)\)
<ul>
<li>\(Subject\)   is an IRI or a string</li>
<li>\(Predicate\) is an IRI representing a relation</li>
<li>\(Object\)    is an IRI or a string</li>
<li>It's essentially the unit of information</li>

</ul></li>
<li class="fragment appear">Data is meant to be retrieved from the internet
<ul>
<li>Open-world assumption must be used</li>

</ul></li>

</ul>


<aside class="notes">
<p>
RDF is a specification on of the data layout
An RDF triple is the essential unit of information, it relates some objects
using a predicate.
</p>

<p>
What is really interesting about RDF, is that IRIs become identifiers for
the data, this enables identifiers to be shared across databases, and also to
have a common vocabulary on the relations.
This change allows different databases to be combined without the need for human
review of the schemas compatibility. No conversions are needed.
</p>

</aside>

</section>
<section id="slide-orgba780ac">
<h4 id="orgba780ac">An example</h4>
<div class="org-src-container">

<pre><code class="txt" >prefix dblpAuthor: &lt;http://dblp.l3s.de/d2r/resource/authors/&gt;
prefix dblpConf:   &lt;http://dblp.l3s.de/d2r/resource/publications/conf/&gt;

dblpConf:sigmod/Stonebraker90    dc:creator  dblpAuthor:Michael_Stonebraker
dblpConf:sigmod/Stonebraker90  rdfs:label    "The Postgres DBMS."
dblpAuthor:Michael_Stonebraker foaf:name     "Michael Stonebraker"
</code></pre>
</div>

</section>
<section id="slide-orgd8b5d4c">
<h4 id="orgd8b5d4c">Why RDF?</h4>
<ul>
<li class="fragment appear">Different databases can be trivially joined
<ul>
<li>No schema compatibility problems or conversions.</li>

</ul></li>
<li class="fragment appear">Database can be sharded</li>

</ul>

</section>
</section>
<section>
<section id="slide-org46d8ec6">
<h3 id="org46d8ec6">Querying Linked Data</h3>
<div class="outline-text-3" id="text-org46d8ec6">
</div></section>
<section id="slide-orgd0ed790">
<h4 id="orgd0ed790">A data model is not enough</h4>
<p>
Databases must be queried to be useful
</p>


<aside class="notes">
<p>
RDF is a data model for storing information, but having information is worthless
without a way to query it
So far LD proposes a model for storing information in a distributed fashion.
</p>

</aside>


</section>
<section id="slide-org6ad78dc">
<h4 id="org6ad78dc">SPARQL</h4>
<p>
A SQL-like language for querying and modifying graph databases
</p>

<ul>
<li class="fragment appear">A query language
<ul>
<li>Queries are RDF graphs with variables and restrictions</li>
<li>Answers are computed by pattern matching</li>

</ul></li>
<li class="fragment appear">SPARQL servers provide
<ul>
<li>An SPARQL endpoint to consume or update RDF data</li>
<li>A store for the data</li>

</ul></li>

</ul>


<aside class="notes">
<p>
SPARQL is a language for querying graphs, it looks like SQL and relies on
subgraph matching specifying queries.
</p>

<p>
SPARQL servers provide endpoints (services) to interact
</p>

</aside>


</section>
<section id="slide-orgd4d73c0">
<h4 id="orgd4d73c0">Problems with SPARQL</h4>
<ul>
<li class="fragment appear">Querying multiple servers is hard
<ul>
<li>Query federation allows specifying multiple servers
<ul>
<li>Lacks discoverability</li>
<li>Queries are harder to write</li>

</ul></li>

</ul></li>
<li class="fragment appear">Computation is done completely server-side
<ul>
<li>Exposing SPARQL endpoints is troublesome</li>
<li>Queries can be computationally hard
<ul>
<li>Implementations often get <i>OoM</i> errors or timeouts (trashing/crashes)</li>

</ul></li>

</ul></li>

</ul>


<aside class="notes">
<p>
SPARQL has a few problems.
</p>

<p>
Servers must handle too much of the complexity as the only task for clients is
to send the query and receive the final answer.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0916a20">
<h2 id="org0916a20">Navigational Queries</h2>
<div class="outline-text-2" id="text-org0916a20">
</div></section>
</section>
<section>
<section id="slide-org5ec23db">
<h3 id="org5ec23db">Navigation</h3>
<div class="outline-text-3" id="text-org5ec23db">
</div></section>
<section id="slide-org6cb382b">
<h4 id="org6cb382b">Searching data the way you browse for it</h4>
<ul>
<li class="fragment appear">You don't know which server has the answer
<ul>
<li>From a starting point you follow links onto your answers</li>

</ul></li>
<li class="fragment appear">Servers just offer data
<ul>
<li>You do the computation and ask for data on the fly</li>

</ul></li>
<li class="fragment appear">You don't know whether you see all the data
<ul>
<li>Open-world semantics are intrinsic</li>
<li>You probably can't have all of it</li>

</ul></li>

</ul>


<aside class="notes">
<p>
While SPARQL seems too centralized for LD, we have been using the web to publish
distributed documents, and have been accessing them by manually going through
them and finding our way though the links.
</p>

</aside>

</section>
<section id="slide-org875bd04">
<h4 id="org875bd04">Property Paths</h4>
<p>
Property paths allow expressing composed relations using regular expressions
over IRIs and their inverses
</p>

<ul>
<li class="fragment appear">Expressive and easy to compute</li>
<li class="fragment appear">Regular expressions are already widely studied</li>
<li class="fragment appear">SPARQL supports them too, but
<ul>
<li>Lacks the discoverability that PP allow</li>
<li>Efficient implementation is tricky, many queries are troublesome
<ul>
<li>Even the standard needed corrections to avoid blow-ups</li>

</ul></li>

</ul></li>

</ul>


<aside class="notes">
<p>
Property Paths allow to express many interesting queries while still being easy
to compute.
</p>

<p>
Property Paths were included on SPARQL 1.1, but they don't help with SPARQL's
discoverability problems and as they are used as patterns rather than relations
they lead to too many answers.
If you are interested on this bad behaviour, there's an example at the end
</p>

</aside>


</section>
<section id="slide-org8ced927">
<h4 id="org8ced927">Property Path examples</h4>
<div class="LaTeX">
<div>
\begin{align*}
(children + parent^{-})& \cdot name  \\
(creator \cdot creator^{-})^+& \cdot name
\end{align*}

</div>

</div>


</section>
</section>
<section>
<section id="slide-org5de7d37">
<h3 id="org5de7d37">Automata</h3>
<div class="outline-text-3" id="text-org5de7d37">
</div></section>
<section id="slide-org5b57852">
<h4 id="org5b57852">Definition</h4>
<p>
Property Path Automata
</p>

<ul>
<li class="fragment appear">An automaton over alphabet of IRIs and their inverses</li>
<li class="fragment appear">Matching requires an initial IRI to pair with the initial State
<ul>
<li>Computing matches needs dereferencing IRIs</li>
<li>Computations looks like resolving a search problem</li>

</ul></li>
<li class="fragment appear">Can be enhanced with filtering on States and Transitions</li>

</ul>

</section>
<section id="slide-orgc2d490d">
<h4 id="orgc2d490d">Example</h4>
<img class="figure" src="graphics/coauth-name.png"/>

</section>
</section>
<section>
<section id="slide-org227075f">
<h3 id="org227075f">Query evaluation</h3>
<div class="outline-text-3" id="text-org227075f">
</div></section>
<section id="slide-org7142ad3">
<h4 id="org7142ad3">Automaton evaluation problem</h4>
<ul>
<li class="fragment appear">Given an RDF graph, an Automaton for it, and a starting RDF node,</li>
<li class="fragment appear">Find 'all' the matching paths</li>

</ul>

</section>
<section id="slide-orgd9c9f3a">
<h4 id="orgd9c9f3a">Evaluating an Automaton query</h4>
<img width="80%" class="figure" src="graphics/coauth-name.png"/>
<div class="stretch">
<iframe data-src="demo.html?data=data/coauthor-small.json" width="100%" height="100%"></iframe>
</div>

</section>
<section id="slide-org9f2af0a">
<h4 id="org9f2af0a">Matching as a Search Problem</h4>
<p>
Matching resembles a search problem
</p>

<ul>
<li class="fragment appear">The problem is a Search Problem over \(RDFGraph \times States\)</li>
<li class="fragment appear">But not only a shortest-path is needed
<ul>
<li>It's easy to tweak the search to get all shortest paths</li>

</ul></li>

</ul>

</section>
<section id="slide-orgddf4932">
<h4 id="orgddf4932">Evaluating using search</h4>
<ul>
<li class="fragment appear">From the search community 3 pathfinding algorithms are well known
<ul>
<li>\(A^*\), BFS (Dijkstra) and DFS</li>
<li>The recursive approach that was previously used resembles DFS</li>

</ul></li>
<li class="fragment appear">BFS and DFS were already tried</li>
<li class="fragment appear">Using \(A^*\) requires additional information about the search space
<ul>
<li>We found an easy way to get it</li>

</ul></li>

</ul>

</section>
<section id="slide-org203fc18">
<h4 id="org203fc18">Heuristic</h4>
<p>
Distances to accepting states are lower bounds for finding answers
</p>

<img class="fragment figure" src="graphics/coauth-name-h.png"/>


</section>
<section id="slide-org51b0f71">
<h4 id="org51b0f71">Implementation</h4>
<ul>
<li class="fragment appear">Search nodes are \((RDFNode, State)\) pairs</li>
<li class="fragment appear">We used a priority queue and an index for the existing search nodes
<ul>
<li>Typical \(A^*\) and BFS structures</li>
<li>Needed for deduplication on DFS</li>

</ul></li>
<li class="fragment appear">We altered the expected cost (priority) to get different behaviours
<ul>
<li>\(A^*\) uses \(f=g+h\), node cost + estimated cost left</li>
<li>BFS uses \(f=g\)</li>
<li>DFS uses \(f=h\)</li>

</ul></li>

</ul>

<aside class="notes">
<p>
Our implementation is publicly available
</p>

</aside>

</section>
<section id="slide-orgfe8e353">
<h4 id="orgfe8e353">Optimizations used</h4>
<ul>
<li class="fragment appear">Parallel expansions
<ul>
<li>Instead of expand any top f-value node, try to expand all of them</li>

</ul></li>
<li class="fragment appear">Early goal declaration
<ul>
<li>Declare goals when before adding nodes to the queue</li>
<li>Avoid adding dead-end nodes
<ul>
<li>Implemented by modifying the heuristic</li>

</ul></li>

</ul></li>
<li class="fragment appear">Precomputed heuristic</li>

</ul>

</section>
<section id="slide-orgdec2e0c">
<h4 id="orgdec2e0c">Heuristic for using Early Expansions</h4>
<p>
Expanding a \((node, state)\) discovers nodes paired with successor states
</p>

<img class="figure" src="graphics/coauth-name-h.png"/>
<img class="fragment figure" src="graphics/coauth-name-sh.png"/>
<aside class="notes">
<p>
This is similar to the path-max idea that a node can only be as promising as the
nodes it leads to considering the cost to reach them.
</p>

</aside>


</section>
</section>
<section>
<section id="slide-org621c8dd">
<h3 id="org621c8dd">Experimental evaluation</h3>
<div class="outline-text-3" id="text-org621c8dd">
</div></section>
<section id="slide-orgc29d766">
<h4 id="orgc29d766">Experiment setup</h4>
<ul>
<li>11 queries using
<ul>
<li>DBLP</li>
<li>DBpedia</li>
<li>Linked Movie Database</li>
<li>YAGO</li>

</ul></li>
<li>Ran on i5-4670 quad-core with 4 GiB RAM</li>
<li>Python multi-process implementation</li>
<li>Search bounds
<ul>
<li>Stop if \(1000\) answers are found</li>
<li>Stop if \(100000\) triples are retrieved</li>
<li>Stop after \(10\) minutes searching</li>

</ul></li>

</ul>


<aside class="notes">
<p>
We experimented with 11 queries over DBLP, DBpedia, LMDB and YAGO.
Some of the queries required using multiple servers without knowing about them
at query time
</p>

<p>
The experiments were done on a server running a 4th gen Intel CPU and 4GiB of
RAM
</p>

<p>
The implementation was done on Python, which offered good libraries and good
enough performance as we already knew that dereference would dominate the time
</p>

<p>
We used bounds on answers retrieved, data downloaded and time in order to avoid
having bad behaved runs
</p>

</aside>


</section>
<section id="slide-org0ad294b">
<h4 id="org0ad294b">Sample query - Coauthor names</h4>
<img class="figure" src="graphics/q1.png"/>
<aside class="notes">
<p>
Here BFS retrieves all papers before retrieving information about the authors
</p>

</aside>


</section>
<section id="slide-org0a5229d">
<h4 id="org0a5229d">Sample query - Bacon Number</h4>
<img class="figure" src="graphics/q2.png"/>
<aside class="notes">
<p>
This query has very deep solutions, and as DFS does not minimize length, it
gathers increasingly longer solutions, so they don't really provide a good
bound for the Bacon number of the actors found.
</p>

</aside>


</section>
<section id="slide-org8626d71">
<h4 id="org8626d71">Results summary</h4>
<p>
Over the 11 queries we counted on how many queries the algorithms performed
the best
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Measure</th>
<th scope="col" class="org-right">A*</th>
<th scope="col" class="org-right">BFS</th>
<th scope="col" class="org-right">DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Requests / Answers</td>
<td class="org-right">11</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-left">Time / Answers</td>
<td class="org-right">11</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>
</tbody>
</table>


<aside class="notes">
<p>
A* seems to be the right mix between BFS and DFS
</p>

</aside>

</section>
<section id="slide-org3ed90f7">
<h4 id="org3ed90f7">Results summary</h4>
<p>
Requests vs answers is the most fair measure as dereference times vary.
We noted that parallelism helps all algorithm
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">Parallel requests allowed</th>
<th scope="col" class="org-right">A*</th>
<th scope="col" class="org-right">BFS</th>
<th scope="col" class="org-right">DFS</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">1</td>
<td class="org-right">11</td>
<td class="org-right">3</td>
<td class="org-right">4</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">7</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">20</td>
<td class="org-right">6</td>
<td class="org-right">3</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">40</td>
<td class="org-right">6</td>
<td class="org-right">4</td>
<td class="org-right">5</td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
Go back and show which algorithm dominated
</p>

</aside>

</section>
<section id="slide-orgee7e7ac">
<h4 id="orgee7e7ac">Experiment discussion</h4>
<ul>
<li>Little CPU usage, under 5%</li>
<li>Memory used is linear on the dereferenced data</li>
<li>Time dominated by dereference time
<ul>
<li>Parallel dereference gives free speedup
<ul>
<li>Gains bounded by data and throughput</li>

</ul></li>

</ul></li>
<li>Optimizing dereference should yield to vast improvements
<ul>
<li>Parallel and reusable connections</li>
<li>Compression</li>
<li>Download only what is needed</li>

</ul></li>

</ul>


<aside class="notes">
<p>
After reviewing the data of the experiments, we found out
</p>
<ul>
<li>CPU usage is minimal</li>
<li>Memory used is mostly the downloaded data, and it is implicitly bounded by dereferencing</li>
<li>Query time was dominated by dereference, using async IO gave a free speedup</li>

</ul>
<p>
as the idle wait was done in parallel, however it's not a panacea as you can be
bounded by the amount of IRIs and also by you Internet connection
</p>

<p>
For further optimizing retrieval, you should only retrieve the data you need,
for this you can use simple SPARQL queries, or a lightweight server like the one
Linked Data Fragments propose
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org078f392">
<h2 id="org078f392">Questions</h2>
</section>
</section>
<section>
<section id="slide-org4c08204">
<h2 id="org4c08204">Extra</h2>
<div class="outline-text-2" id="text-org4c08204">
</div></section>
</section>
<section>
<section id="slide-orgcfaf2a5">
<h3 id="orgcfaf2a5">Heuristic optimization demo</h3>
<div class="outline-text-3" id="text-orgcfaf2a5">
</div></section>
<section id="slide-orga4ccd18">
<h4 id="orga4ccd18">A weird behaviour</h4>
<p>
Notice what happens when you just discovered an IRI that is a goal for a new
f-value level
</p>

<ul>
<li>You can declare that IRI goal when you expand it's parent
<ul>
<li>No need to expand that IRI yet</li>

</ul></li>
<li>A weird ordering appears
<ul>
<li>Siblings of the goal's parent might lead to similar solutions (same \(f\))</li>
<li>But tie breaking prefers greater \(g\), thus \(h=0\) is preferred</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org7ad46e8">
<h3 id="org7ad46e8">Paths prove relation</h3>
<div class="outline-text-3" id="text-org7ad46e8">
</div></section>
<section id="slide-org185146a">
<h4 id="org185146a">Computing all of them seems pointless</h4>
<p>
Looking for all patterns that match can be too much
</p>
<ul>
<li class="fragment appear">A toy database:
<ul>
<li>Alphabet and a less than relation</li>

</ul></li>
<li class="fragment appear">Which patterns match \(a \cdot lessThan^* \cdot X\)?
<ul>
<li>a &lt; z</li>
<li>a &lt; b &lt; c &lt; &#x2026; &lt; z</li>
<li>There's one match per subset of \(\{b..y\}\)</li>

</ul></li>
<li class="fragment appear">Less or equal leads to infinite matches!</li>
<li class="fragment appear">Is the data flawed?
<ul>
<li>On the internet you won't control it. You must avoid this</li>

</ul></li>

</ul>

</section>
</section>
<section>
<section id="slide-org39bf1de">
<h3 id="org39bf1de"><span class="todo TODO">TODO</span> Evaluation - No parallelism</h3>
<div class="outline-text-3" id="text-org39bf1de">
</div></section>
<section id="slide-org1ace289">
<h4 id="org1ace289"><span class="todo TODO">TODO</span> Experiments</h4>
<p>
Available on the repo
</p>

</section>
<section id="slide-org8d354ff">
<h4 id="org8d354ff"><span class="todo TODO">TODO</span> Query 1</h4>

</section>
</section>
<section>
<section id="slide-org858ba90">
<h3 id="org858ba90"><span class="todo TODO">TODO</span> Evaluation - Parallelism effect</h3>
<div class="outline-text-3" id="text-org858ba90">
</div></section>
<section id="slide-orgdb54cee">
<h4 id="orgdb54cee"><span class="todo TODO">TODO</span> Query 1 - P40</h4>

</section>
</section>
<section>
<section id="slide-org729368d">
<h2 id="org729368d">Thanks</h2>
<div class="outline-text-2" id="text-org729368d">
</div></section>
</section>
<section>
<section id="slide-org5d904a2">
<h3 id="org5d904a2">Config</h3>
<div class="outline-text-3" id="text-org5d904a2">
</div></section>
<section id="slide-org986a987">
<h4 id="org986a987">Theme setup</h4>
<p>
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/black.css'); return false;">Black (default)</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/white.css'); return false;">White</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/league.css'); return false;">League</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/sky.css'); return false;">Sky</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/beige.css'); return false;">Beige</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/simple.css'); return false;">Simple</a> <br>
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/serif.css'); return false;">Serif</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/blood.css'); return false;">Blood</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/night.css'); return false;">Night</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/moon.css'); return false;">Moon</a> -
<a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/solarized.css'); return false;">Solarized</a>
</p>
</section>
</section>
</div>
</div>
<script src="./lib/js/head.min.js"></script>
<script src="./js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'h.v',
rollingLinks: true,
keyboard: true,
overview: true,
width: 1366,
height: 768,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'slide', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: '2',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
{ src: 'plugin/math/math.js', async: true }, { src: 'plugin/zoom-js/zoom.js', async: true },
 { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
<script src="//0.0.0.0:35729/livereload.js?snipver=1" async="" defer=""></script></body>
</html>
